/* 
 * Ardesia -- a program for painting on the screen
 * with this program you can play, draw, learn and teach
 * This program has been written such as a freedom sonet
 * We believe in the freedom and in the freedom of education
 *
 * Copyright (C) 2009 Pilolli Pietro <pilolli@fbk.eu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 */
 
/* This is the file where put the callback of the events generated by the ardesia interface
 * If you are trying to add some functionality and you have already add a button in interface
 * you are in the right place. In any case good reading!
 * Pay attentioni; all the things are delegated to the annotate commandline tool
 */

#ifdef HAVE_CONFIG_H
  #include <config.h>
#endif

#include <gtk/gtk.h>

#include "interface.h"
#include "recorder.h"
#include "saver.h"
#include "color_selector.h"
#include "preference_dialog.h"
#include "info_dialog.h"

#include "annotate.h"

#include "stdlib.h"
#include "unistd.h"
#include "stdio.h"
#include <string.h> 

#include <X11/Xutil.h>
#include <X11/Xatom.h>

#include <math.h>
#include <utils.h>
#include <background.h>

#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>


#define COLORSIZE 9

/* annotation is visible */
gboolean     visible = TRUE;

/* pencil is selected */
gboolean     pencil = TRUE;

/* grab when leave */
gboolean     grab = FALSE;

/* selected color in RGBA format */
gchar*       color = NULL;

/* selected line width */
int          tickness = 15;

/* highlighter flag */
gboolean     highlighter = FALSE;

/* rectifier flag */
gboolean     rectifier = FALSE;

/* rounder flag */
gboolean     rounder = FALSE;

/* arrow=0 mean no arrow, arrow=1 mean normal arrow, arrow=2 mean double arrow */
int        arrow = 0;

/* Default folder where store images and videos */
char*       workspace_dir = NULL;


/* Called when close the program */
gboolean  quit()
{
  gboolean ret = FALSE;
  quit_recorder();
  clear_background();
  annotate_quit();
  GtkWidget* main_window = GTK_WIDGET(gtk_builder_get_object(gtkBuilder,"winMain"));
  gtk_widget_destroy(main_window);
  g_free(color);
  g_free(workspace_dir);
  g_object_unref (gtkBuilder); 
  gtk_main_quit();
  exit(ret);
}


/* Add alpha channel to build the RGBA string */
void add_alpha(char *color)
{
  if (highlighter)
    {
      strncpy(&color[6], "88", 2);
    }
  else
    {
      strncpy(&color[6], "FF", 2);
    }
   color[8]=0;
}


/* free color */
void set_color(char* selected_color)
{
  grab = TRUE;
  pencil = TRUE;
  strcpy(color, selected_color);
  
  add_alpha(color);
  
  annotate_set_color(color);
}


gboolean on_window_configure_event (GtkWidget *widget, GdkEventExpose *event, gpointer user_data)
{
  if (color == NULL)
    {
      color = malloc(COLORSIZE);
      set_color("FF0000");
      add_alpha(color);
    }
  return TRUE;
}


/* Start to annotate calling annotate */
void annotate()
{
  annotate_set_rectifier(rectifier);
  
  annotate_set_rounder(rounder);
  
  annotate_set_width(tickness);

  annotate_set_arrow(arrow);

  annotate_toggle_grab();
}


/* Start to erase calling annotate */
void erase()
{
  annotate_set_width(tickness); 
  annotate_eraser_grab();
}


/* Start event handler section */


/* Called when push the quit button */
gboolean on_quit                          (GtkWidget       *widget,
                                           GdkEvent        *event,
                                           gpointer         user_data)
{
  return quit();
}


/* Called when push the info button */
gboolean on_info                         (GtkToolButton   *toolbutton,
					   gpointer         user_data)
{
  start_info_dialog(toolbutton, get_annotation_window());
  annotate();
  return TRUE;
}


/* Called when leave the window */
gboolean on_winMain_leave_notify_event   (GtkWidget       *widget,
                                           GdkEvent        *event,
                                           gpointer         user_data)
{
  if (grab)
  {
    if (pencil)
      { 
        annotate();
      }
    else
      {
        erase();
      }
  }
  grab=FALSE;
  return TRUE;
}


gboolean on_winMain_delete_event          (GtkWidget       *widget,
                                           GdkEvent        *event,
                                           gpointer         user_data)
{
  return quit();
}


void on_toolsEraser_activate              (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  grab = TRUE;
  pencil = FALSE;
}


void
on_toolsHighlighter_activate          (GtkToolButton   *toolbutton,
				      gpointer         user_data)
{
  grab = TRUE;
  if (gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(toolbutton)))
    {
       highlighter = TRUE;
    }
  else
    {
       highlighter = FALSE;
    }
  add_alpha(color);
}


void
on_toolsRectifier_activate          (GtkToolButton   *toolbutton,
				      gpointer         user_data)
{
  grab = TRUE;
  if (gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(toolbutton)))
    {
       /* if rounder is active release it */
      GtkToggleToolButton* rounderToolButton = GTK_TOGGLE_TOOL_BUTTON(gtk_builder_get_object(gtkBuilder,"buttonRounder"));
      if (gtk_toggle_tool_button_get_active(rounderToolButton))
        {
	  gtk_toggle_tool_button_set_active(rounderToolButton, FALSE); 
          rounder = FALSE;
        }
       rectifier = TRUE;
    }
  else
    {
       rectifier = FALSE;
    }
}


void
on_toolsRounder_activate          (GtkToolButton   *toolbutton,
				      gpointer         user_data)
{
  grab = TRUE;
  if (gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(toolbutton)))
    {
      /* if rectifier is active release it */
      GtkToggleToolButton* rectifierToolButton = GTK_TOGGLE_TOOL_BUTTON(gtk_builder_get_object(gtkBuilder,"buttonRectifier"));
      if (gtk_toggle_tool_button_get_active( rectifierToolButton))
        {
	  gtk_toggle_tool_button_set_active( rectifierToolButton, FALSE); 
          rectifier = FALSE;
        }
       rounder = TRUE;
    }
  else
    {
       rounder = FALSE;
    }
}


void
on_toolsFiller_activate          (GtkToolButton   *toolbutton,
                                      gpointer         user_data)
{
  grab = TRUE;
  annotate_fill();
}


void on_toolsArrow_activate               (GtkToolButton   *toolbutton,
				           gpointer         user_data)
{
  grab = TRUE;
  if (gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(toolbutton)))
    {
      /* if single arrow is active release it */
      GtkToggleToolButton* doubleArrowToolButton = GTK_TOGGLE_TOOL_BUTTON(gtk_builder_get_object(gtkBuilder,"buttonDoubleArrow"));
      if (gtk_toggle_tool_button_get_active(doubleArrowToolButton))
        {
	  gtk_toggle_tool_button_set_active(doubleArrowToolButton, FALSE); 
        }
      arrow=1;
    }
  else
    {
      arrow=0;
    }
}


void on_toolsDoubleArrow_activate         (GtkToolButton   *toolbutton,
					   gpointer         user_data)
{
  grab = TRUE;
  if (gtk_toggle_tool_button_get_active(GTK_TOGGLE_TOOL_BUTTON(toolbutton)))
    {
      /* if single arrow is active release it */
      GtkToggleToolButton* arrowToolButton = GTK_TOGGLE_TOOL_BUTTON(gtk_builder_get_object(gtkBuilder,"buttonArrow"));
      if (gtk_toggle_tool_button_get_active(arrowToolButton))
        {
	  gtk_toggle_tool_button_set_active(arrowToolButton, FALSE); 
        }
      arrow=2;
    }
  else
    {
      arrow=0;
    }
}


void on_toolsVisible_activate             (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  if (visible)
    {
      annotate_hide_annotation();
      grab = FALSE;
      visible=FALSE;
      /* set tooltip to unhide */
      gtk_tool_item_set_tooltip_text((GtkToolItem *) toolbutton,"Unhide");
    }
  else
    {
      annotate_show_annotation();
      visible=TRUE;
      grab = TRUE;
      /* set tooltip to hide */
      gtk_tool_item_set_tooltip_text((GtkToolItem *) toolbutton,"Hide");
    }
}


void on_toolsScreenShot_activate	  (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  grab = FALSE;
  start_save_image_dialog(toolbutton, get_annotation_window(), &workspace_dir);
  annotate();
}


void on_toolsRecorder_activate            (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{ 
  grab = FALSE;
  if(is_recording())
    {
      quit_recorder();
      /* set stop tooltip */ 
      gtk_tool_item_set_tooltip_text((GtkToolItem *) toolbutton,"Record");
      /* put icon to record */
      gtk_tool_button_set_stock_id (toolbutton, "gtk-media-record");
    }
  else
    {      
      /* Release grab */
      annotate_release_grab ();
      /* the recording is not active */ 
      gboolean status = start_save_video_dialog(toolbutton, get_annotation_window(), &workspace_dir);
      if (status)
        {
          /* set stop tooltip */ 
          gtk_tool_item_set_tooltip_text((GtkToolItem *) toolbutton,"Stop");
          /* put icon to stop */
          gtk_tool_button_set_stock_id (toolbutton, "gtk-media-stop");
        }
      else
       {
	  gtk_widget_hide(GTK_WIDGET(toolbutton));
           
       }
    }
  annotate();
}


void on_thickScale_value_changed          (GtkHScale   *hScale,
					   gpointer         user_data)
{
  grab = TRUE;
  tickness=gtk_range_get_value(&hScale->scale.range);
}


void on_toolsPreferences_activate	  (GtkToolButton   *toolbutton,
					   gpointer         user_data)
{
  grab = FALSE;
  start_preference_dialog(toolbutton, get_annotation_window());
  annotate();
}


void on_buttonUnlock_activate              (GtkToolButton   *toolbutton,
					   gpointer         user_data)
{
  grab = FALSE;
  annotate_release_grab ();
}


void on_buttonUndo_activate              (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  grab = TRUE;
  annotate_undo();
}


void on_buttonRedo_activate              (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  grab = TRUE;
  annotate_redo();
}


void on_buttonClear_activate              (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  grab = TRUE;
  annotate_clear_screen (); 
}


void on_buttonColor_activate	          (GtkToolButton   *toolbutton,
					   gpointer         user_data)
{
  grab = FALSE;
  pencil = TRUE;
  set_color(start_color_selector_dialog(toolbutton, get_annotation_window(), color));
  annotate();
}


/* Start color handlers */

void on_colorBlack_activate               (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  set_color("000000");
}


void on_colorBlue_activate                (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  set_color("3333CC");
}


void on_colorRed_activate                 (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  set_color("FF0000");
}


void on_colorGreen_activate               (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  set_color("008000");
}


void on_colorLightBlue_activate           (GtkToolButton   *toolbutton,
                                           gpointer         user_data)
{
  set_color("00C0FF");
}


void on_colorLightGreen_activate            (GtkToolButton   *toolbutton,
                                             gpointer         user_data)
{
  set_color("00FF00");
}


void on_colorMagenta_activate               (GtkToolButton   *toolbutton,
                                             gpointer         user_data)
{
  set_color("FF00FF");
}


void on_colorOrange_activate                (GtkToolButton   *toolbutton,
                                             gpointer         user_data)
{
  set_color("FF8000");
}


void on_colorYellow_activate                (GtkToolButton   *toolbutton,
                                             gpointer         user_data)
{
  set_color("FFFF00");
}


void on_colorWhite_activate                (GtkToolButton   *toolbutton,
	       			            gpointer         user_data)
{
  set_color("FFFFFF");
}


